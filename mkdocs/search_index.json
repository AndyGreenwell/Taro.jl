{
    "docs": [
        {
            "location": "/", 
            "text": "Taro \u2013 Work with Excel, Word and PDF files in Julia\n\n\nTaro is a utility belt of functions to work with document files in Julia. It uses \nApache Tika\n, \nApache POI\n and \nApache FOP\n  (via \nJavaCall\n) to work with Word, Excel and PDF files.\n\n\nPackage Features\n\n\n\n\nExtract raw text from Word, Excel, PDF files\n\n\nExtract tabular data from Excel files into a DataFrame (\nreadxl\n, like \nreadtable\n)\n\n\nAPI to read and write Excel files from Julia\n\n\nConvert \nxsl-fo\n files to PDFs for automated report generation\n\n\n\n\nInstallation\n\n\njulia\n Pkg.add(\nTaro\n)\n\n\n\n\nOn installation, the \ntika-app-1.4.jar\n file will be downloaded from \nMaven Central\n and \nfop-2.0\n will be downloaded from an Apache mirror.\n\n\nUsage\n\n\nBefore calling any function within this package, the \ninit()\n method \nmust\n be called. This will set up the correct classpath, and initialise the JVM.\n\n\n using Taro\n Taro.init()", 
            "title": "Home"
        }, 
        {
            "location": "/#taro-work-with-excel-word-and-pdf-files-in-julia", 
            "text": "Taro is a utility belt of functions to work with document files in Julia. It uses  Apache Tika ,  Apache POI  and  Apache FOP   (via  JavaCall ) to work with Word, Excel and PDF files.", 
            "title": "Taro \u2013 Work with Excel, Word and PDF files in Julia"
        }, 
        {
            "location": "/#package-features", 
            "text": "Extract raw text from Word, Excel, PDF files  Extract tabular data from Excel files into a DataFrame ( readxl , like  readtable )  API to read and write Excel files from Julia  Convert  xsl-fo  files to PDFs for automated report generation", 
            "title": "Package Features"
        }, 
        {
            "location": "/#installation", 
            "text": "julia  Pkg.add( Taro )  On installation, the  tika-app-1.4.jar  file will be downloaded from  Maven Central  and  fop-2.0  will be downloaded from an Apache mirror.", 
            "title": "Installation"
        }, 
        {
            "location": "/#usage", 
            "text": "Before calling any function within this package, the  init()  method  must  be called. This will set up the correct classpath, and initialise the JVM.   using Taro\n Taro.init()", 
            "title": "Usage"
        }, 
        {
            "location": "/guide/extract/", 
            "text": "Data Extraction\n\n\nTaro includes a few high level functions that extract data from various document formats.\n\n\nText extraction\n\n\nThe \nTaro.extract\n method retrieves document metadata and the body text of a document, using \nApache Tika\n. Formats \nsupported by Tika\n include MS Office and Open Office documents, as well as PDF files.\n\n\nThe function return a Tuple of a Dict and String. The Dict contains name/value pairs of various metadata from the document, while the string contains the body text of the document.\n\n\n\njulia\n testfile = joinpath(Pkg.dir(),\nTaro\n,\ntest\n,\nWhyJulia.docx\n);\n\njulia\n meta, text = Taro.extract(testfile);\n\njulia\n meta[\nLast-Save-Date\n]\n\n2013-12-28T00:17:00Z\n\n\njulia\n typeof(text)\nUTF8String\n\njulia\n text[1:53]\n\nWhy we created Julia\\n\\nIn short, because we are greedy\n\n\n\n\n\n\n\nRead Excel files into a DataFrame\n\n\nThe \nTaro.readxl\n method reads a rectangular region from an excel sheet, and returns a \nDataframe\n. This function takes as an input parameter the name and path of the Excel file to be read. A sheet name (or number) can optionally be supplied. If no sheet information is given, the first sheet (index 0) is read. Finally, this function is provided with the rectangular region from which data is extracted. This region is specified as an excel range.\n\n\nThis function is similar to, and inspired by, the \nreadtable\n function in DataFrames.\n\n\n\njulia\n testfile = joinpath(Pkg.dir(),\nTaro\n,\ntest\n,\ndf-test.xlsx\n);\n\njulia\n Taro.readxl(testfile, \nSheet1\n, \nB2:F10\n)\n8\u00d75 DataFrames.DataFrame\n\u2502 Row \u2502 H1  \u2502 H2  \u2502 H3  \u2502 H4  \u2502 H5    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 \na\n \u2502 1.0 \u2502 1.0 \u2502 1.0 \u2502 \na a\n \u2502\n\u2502 2   \u2502 \nb\n \u2502 2.0 \u2502 2.0 \u2502 1.0 \u2502 \nb b\n \u2502\n\u2502 3   \u2502 \nc\n \u2502 NA  \u2502 3.0 \u2502 0.0 \u2502 \nc c\n \u2502\n\u2502 4   \u2502 \nd\n \u2502 4.0 \u2502 NA  \u2502 NA  \u2502 \nd d\n \u2502\n\u2502 5   \u2502 \ne\n \u2502 5.0 \u2502 5.0 \u2502 1.0 \u2502 \ne e\n \u2502\n\u2502 6   \u2502 NA  \u2502 6.0 \u2502 6.0 \u2502 1.0 \u2502 \n \n   \u2502\n\u2502 7   \u2502 \ng\n \u2502 7.0 \u2502 7.0 \u2502 1.0 \u2502 \ng g\n \u2502\n\u2502 8   \u2502 \nh\n \u2502 8.0 \u2502 8.0 \u2502 1.0 \u2502 \nh h\n \u2502\n\njulia\n Taro.readxl(testfile, \nSheet1\n, \nB3:F10\n; header=false)\n8\u00d75 DataFrames.DataFrame\n\u2502 Row \u2502 x1  \u2502 x2  \u2502 x3  \u2502 x4  \u2502 x5    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 \na\n \u2502 1.0 \u2502 1.0 \u2502 1.0 \u2502 \na a\n \u2502\n\u2502 2   \u2502 \nb\n \u2502 2.0 \u2502 2.0 \u2502 1.0 \u2502 \nb b\n \u2502\n\u2502 3   \u2502 \nc\n \u2502 NA  \u2502 3.0 \u2502 0.0 \u2502 \nc c\n \u2502\n\u2502 4   \u2502 \nd\n \u2502 4.0 \u2502 NA  \u2502 NA  \u2502 \nd d\n \u2502\n\u2502 5   \u2502 \ne\n \u2502 5.0 \u2502 5.0 \u2502 1.0 \u2502 \ne e\n \u2502\n\u2502 6   \u2502 NA  \u2502 6.0 \u2502 6.0 \u2502 1.0 \u2502 \n \n   \u2502\n\u2502 7   \u2502 \ng\n \u2502 7.0 \u2502 7.0 \u2502 1.0 \u2502 \ng g\n \u2502\n\u2502 8   \u2502 \nh\n \u2502 8.0 \u2502 8.0 \u2502 1.0 \u2502 \nh h\n \u2502\n\njulia\n Taro.readxl(testfile, \nSheet1\n, \nB3:F10\n; header=false, nastrings=[\n \n])\n8\u00d75 DataFrames.DataFrame\n\u2502 Row \u2502 x1  \u2502 x2  \u2502 x3  \u2502 x4  \u2502 x5    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 \na\n \u2502 1.0 \u2502 1.0 \u2502 1.0 \u2502 \na a\n \u2502\n\u2502 2   \u2502 \nb\n \u2502 2.0 \u2502 2.0 \u2502 1.0 \u2502 \nb b\n \u2502\n\u2502 3   \u2502 \nc\n \u2502 NA  \u2502 3.0 \u2502 0.0 \u2502 \nc c\n \u2502\n\u2502 4   \u2502 \nd\n \u2502 4.0 \u2502 NA  \u2502 NA  \u2502 \nd d\n \u2502\n\u2502 5   \u2502 \ne\n \u2502 5.0 \u2502 5.0 \u2502 1.0 \u2502 \ne e\n \u2502\n\u2502 6   \u2502 NA  \u2502 6.0 \u2502 6.0 \u2502 1.0 \u2502 NA    \u2502\n\u2502 7   \u2502 \ng\n \u2502 7.0 \u2502 7.0 \u2502 1.0 \u2502 \ng g\n \u2502\n\u2502 8   \u2502 \nh\n \u2502 8.0 \u2502 8.0 \u2502 1.0 \u2502 \nh h\n \u2502", 
            "title": "Extraction"
        }, 
        {
            "location": "/guide/extract/#data-extraction", 
            "text": "Taro includes a few high level functions that extract data from various document formats.", 
            "title": "Data Extraction"
        }, 
        {
            "location": "/guide/extract/#text-extraction", 
            "text": "The  Taro.extract  method retrieves document metadata and the body text of a document, using  Apache Tika . Formats  supported by Tika  include MS Office and Open Office documents, as well as PDF files.  The function return a Tuple of a Dict and String. The Dict contains name/value pairs of various metadata from the document, while the string contains the body text of the document.  \njulia  testfile = joinpath(Pkg.dir(), Taro , test , WhyJulia.docx );\n\njulia  meta, text = Taro.extract(testfile);\n\njulia  meta[ Last-Save-Date ] 2013-12-28T00:17:00Z \n\njulia  typeof(text)\nUTF8String\n\njulia  text[1:53] Why we created Julia\\n\\nIn short, because we are greedy", 
            "title": "Text extraction"
        }, 
        {
            "location": "/guide/extract/#read-excel-files-into-a-dataframe", 
            "text": "The  Taro.readxl  method reads a rectangular region from an excel sheet, and returns a  Dataframe . This function takes as an input parameter the name and path of the Excel file to be read. A sheet name (or number) can optionally be supplied. If no sheet information is given, the first sheet (index 0) is read. Finally, this function is provided with the rectangular region from which data is extracted. This region is specified as an excel range.  This function is similar to, and inspired by, the  readtable  function in DataFrames.  \njulia  testfile = joinpath(Pkg.dir(), Taro , test , df-test.xlsx );\n\njulia  Taro.readxl(testfile,  Sheet1 ,  B2:F10 )\n8\u00d75 DataFrames.DataFrame\n\u2502 Row \u2502 H1  \u2502 H2  \u2502 H3  \u2502 H4  \u2502 H5    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502  a  \u2502 1.0 \u2502 1.0 \u2502 1.0 \u2502  a a  \u2502\n\u2502 2   \u2502  b  \u2502 2.0 \u2502 2.0 \u2502 1.0 \u2502  b b  \u2502\n\u2502 3   \u2502  c  \u2502 NA  \u2502 3.0 \u2502 0.0 \u2502  c c  \u2502\n\u2502 4   \u2502  d  \u2502 4.0 \u2502 NA  \u2502 NA  \u2502  d d  \u2502\n\u2502 5   \u2502  e  \u2502 5.0 \u2502 5.0 \u2502 1.0 \u2502  e e  \u2502\n\u2502 6   \u2502 NA  \u2502 6.0 \u2502 6.0 \u2502 1.0 \u2502       \u2502\n\u2502 7   \u2502  g  \u2502 7.0 \u2502 7.0 \u2502 1.0 \u2502  g g  \u2502\n\u2502 8   \u2502  h  \u2502 8.0 \u2502 8.0 \u2502 1.0 \u2502  h h  \u2502\n\njulia  Taro.readxl(testfile,  Sheet1 ,  B3:F10 ; header=false)\n8\u00d75 DataFrames.DataFrame\n\u2502 Row \u2502 x1  \u2502 x2  \u2502 x3  \u2502 x4  \u2502 x5    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502  a  \u2502 1.0 \u2502 1.0 \u2502 1.0 \u2502  a a  \u2502\n\u2502 2   \u2502  b  \u2502 2.0 \u2502 2.0 \u2502 1.0 \u2502  b b  \u2502\n\u2502 3   \u2502  c  \u2502 NA  \u2502 3.0 \u2502 0.0 \u2502  c c  \u2502\n\u2502 4   \u2502  d  \u2502 4.0 \u2502 NA  \u2502 NA  \u2502  d d  \u2502\n\u2502 5   \u2502  e  \u2502 5.0 \u2502 5.0 \u2502 1.0 \u2502  e e  \u2502\n\u2502 6   \u2502 NA  \u2502 6.0 \u2502 6.0 \u2502 1.0 \u2502       \u2502\n\u2502 7   \u2502  g  \u2502 7.0 \u2502 7.0 \u2502 1.0 \u2502  g g  \u2502\n\u2502 8   \u2502  h  \u2502 8.0 \u2502 8.0 \u2502 1.0 \u2502  h h  \u2502\n\njulia  Taro.readxl(testfile,  Sheet1 ,  B3:F10 ; header=false, nastrings=[   ])\n8\u00d75 DataFrames.DataFrame\n\u2502 Row \u2502 x1  \u2502 x2  \u2502 x3  \u2502 x4  \u2502 x5    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502  a  \u2502 1.0 \u2502 1.0 \u2502 1.0 \u2502  a a  \u2502\n\u2502 2   \u2502  b  \u2502 2.0 \u2502 2.0 \u2502 1.0 \u2502  b b  \u2502\n\u2502 3   \u2502  c  \u2502 NA  \u2502 3.0 \u2502 0.0 \u2502  c c  \u2502\n\u2502 4   \u2502  d  \u2502 4.0 \u2502 NA  \u2502 NA  \u2502  d d  \u2502\n\u2502 5   \u2502  e  \u2502 5.0 \u2502 5.0 \u2502 1.0 \u2502  e e  \u2502\n\u2502 6   \u2502 NA  \u2502 6.0 \u2502 6.0 \u2502 1.0 \u2502 NA    \u2502\n\u2502 7   \u2502  g  \u2502 7.0 \u2502 7.0 \u2502 1.0 \u2502  g g  \u2502\n\u2502 8   \u2502  h  \u2502 8.0 \u2502 8.0 \u2502 1.0 \u2502  h h  \u2502", 
            "title": "Read Excel files into a DataFrame"
        }, 
        {
            "location": "/guide/hssf/", 
            "text": "Read and Write Excel Files\n\n\nThe \nTaro.readxl\n function is a simple, high level method to read tabular data from Excel files into a Julia DataFrames. For more control over reading files cell by cell, and for creating or modifyting  excel files,  this package exposes functions to read, create and write workbooks, sheets, rows and cells. The functions are modelled on the underlying POI API (converted to functional form), which in turn is based on the structure of an Excel file.\n\n\nt=now()\nw=Workbook()\ns=createSheet(w, \nruntests\n)\nr=createRow(s, 1)\nc=createCell(r, 1); setCellValue(c, \nA String\n)\nc=createCell(r, 2); setCellValue(c, 25)\nc=createCell(r, 3); setCellValue(c, 2.5)\nc=createCell(r, 4); setCellValue(c, t)\ns=createCellStyle(w)\nsetDataFormat(w, s, \nm/d/yy h:mm\n)\nsetCellStyle(c, s)\nc=createCell(r, 5); setCellFormula(c, \nC2+D2\n)\nwrite(Pkg.dir(\nTaro\n, \ntest\n, \nwrite-tests.xlsx\n), w)\n\n\n\n\nWe can now read the file we just wrote, and verify the values we inserted.\n\n\n\njulia\n w2=Workbook(Pkg.dir(\nTaro\n, \ntest\n, \nwrite-tests.xlsx\n))\nJavaCall.JavaObject{symbol(\norg.apache.poi.ss.usermodel.Workbook\n)}(Ptr{Void} @0x00007fe76bbe65c0)\n\njulia\n s2 = getSheet(w2, \nruntests\n)\nJavaCall.JavaObject{symbol(\norg.apache.poi.ss.usermodel.Sheet\n)}(Ptr{Void} @0x00007fe76bbe65b0)\n\njulia\n r2 = getRow(s2, 1)\nJavaCall.JavaObject{symbol(\norg.apache.poi.ss.usermodel.Row\n)}(Ptr{Void} @0x00007fe76bbe6498)\n\njulia\n c2 = getCell(r2, 1); getCellValue(c2)\n\nA String\n\n\njulia\n c2 = getCell(r2, 2); getCellValue(c2)\n25.0\n\njulia\n c2 = getCell(r2, 3); getCellValue(c2)\n2.5\n\njulia\n c2 = getCell(r2, 4); getCellValue(c2)\n2016-06-14T22:47:38\n\njulia\n c2 = getCell(r2, 5); getCellFormula(c2)\n\nC2+D2", 
            "title": "Excel"
        }, 
        {
            "location": "/guide/hssf/#read-and-write-excel-files", 
            "text": "The  Taro.readxl  function is a simple, high level method to read tabular data from Excel files into a Julia DataFrames. For more control over reading files cell by cell, and for creating or modifyting  excel files,  this package exposes functions to read, create and write workbooks, sheets, rows and cells. The functions are modelled on the underlying POI API (converted to functional form), which in turn is based on the structure of an Excel file.  t=now()\nw=Workbook()\ns=createSheet(w,  runtests )\nr=createRow(s, 1)\nc=createCell(r, 1); setCellValue(c,  A String )\nc=createCell(r, 2); setCellValue(c, 25)\nc=createCell(r, 3); setCellValue(c, 2.5)\nc=createCell(r, 4); setCellValue(c, t)\ns=createCellStyle(w)\nsetDataFormat(w, s,  m/d/yy h:mm )\nsetCellStyle(c, s)\nc=createCell(r, 5); setCellFormula(c,  C2+D2 )\nwrite(Pkg.dir( Taro ,  test ,  write-tests.xlsx ), w)  We can now read the file we just wrote, and verify the values we inserted.  \njulia  w2=Workbook(Pkg.dir( Taro ,  test ,  write-tests.xlsx ))\nJavaCall.JavaObject{symbol( org.apache.poi.ss.usermodel.Workbook )}(Ptr{Void} @0x00007fe76bbe65c0)\n\njulia  s2 = getSheet(w2,  runtests )\nJavaCall.JavaObject{symbol( org.apache.poi.ss.usermodel.Sheet )}(Ptr{Void} @0x00007fe76bbe65b0)\n\njulia  r2 = getRow(s2, 1)\nJavaCall.JavaObject{symbol( org.apache.poi.ss.usermodel.Row )}(Ptr{Void} @0x00007fe76bbe6498)\n\njulia  c2 = getCell(r2, 1); getCellValue(c2) A String \n\njulia  c2 = getCell(r2, 2); getCellValue(c2)\n25.0\n\njulia  c2 = getCell(r2, 3); getCellValue(c2)\n2.5\n\njulia  c2 = getCell(r2, 4); getCellValue(c2)\n2016-06-14T22:47:38\n\njulia  c2 = getCell(r2, 5); getCellFormula(c2) C2+D2", 
            "title": "Read and Write Excel Files"
        }, 
        {
            "location": "/guide/fo/", 
            "text": "Taro has an interface to the \nApache FOP\n project. This allows you to generate professional quality PDF files from \nXSL-FO\n layout definition templates. Please see the \nFOP Documentation\n for details.\n\n\nThe \nTaro.fo\n function take two parameters: an input FO file name, and an output PDF file name, and creates the latter from the former. The FO file is usually created by injecting dynamic data into a template. \n\n\nusing Taro\n#Use Mustache.jl to inject content into the template\n#stored in tables.fo.tmpl\nusing Mustache\n#Using Faker to generate fake date for the test\nusing Faker\n\n\ntdir = joinpath(Pkg.dir(\nTaro\n),\nexamples\n)\n#Load template to memory from file\ntmpl = Mustache.template_from_file(joinpath(tdir, \ntables.fo.tmpl\n))\n\n#Generate Fake data\nd=Array(Dict, 100);\nfor i in 1:length(d)\n    d[i] = Faker.simple_profile()\nend\n\n#Create temporary file to store the rendered fo file\ntn, to=mktemp()\n#render the mustache template to fo file\n#This step injects the dynamic data into the template\nfo=render(tmpl, D=d)\nwrite(to, fo )\nclose(to)\n\n#convert the FO file to PDF\nTaro.fo(tn, joinpath(tdir,\ntables.pdf\n))", 
            "title": "XSL-FO"
        }, 
        {
            "location": "/api/", 
            "text": "JavaCall.JavaObject\n\n\nTaro.Cell\n\n\nTaro.CellStyle\n\n\nTaro.Row\n\n\nTaro.Sheet\n\n\nTaro.Workbook\n\n\nBase.write\n\n\nTaro.createCellStyle\n\n\nTaro.createSheet\n\n\nTaro.extract\n\n\nTaro.fo\n\n\nTaro.fromExcelDate\n\n\nTaro.getCellFormula\n\n\nTaro.getCellType\n\n\nTaro.getCellValue\n\n\nTaro.getExcelDate\n\n\nTaro.getSheet\n\n\nTaro.isCellDateFormatted\n\n\nTaro.readxl\n\n\nTaro.setCellFormula\n\n\nTaro.setCellStyle\n\n\nTaro.setCellValue\n\n\nTaro.setDataFormat\n\n\n\n\n#\n\n\nJavaCall.JavaObject\n \n \nType\n.\n\n\nA Julia wrapper around a JNI object pointer\n\n\n#\n\n\nTaro.Cell\n \n \nType\n.\n\n\nA cell within an excel sheet. Most operations to get or set values occur on a cell. Wrapper for Java class \norg.apache.poi.ss.usermodel.Cell\n\n\n#\n\n\nTaro.CellStyle\n \n \nType\n.\n\n\nA Cell style. Wrapper for Java class \norg.apache.poi.ss.usermodel.CellStyle\n\n\n#\n\n\nTaro.Row\n \n \nType\n.\n\n\nA row in a sheet. Contains cells\n\n\n#\n\n\nTaro.Sheet\n \n \nType\n.\n\n\nAn excel Sheet, contained within a workbook. Wrapper around the Java class \norg.apache.poi.ss.usermodel.Sheet\n.\n\n\n#\n\n\nTaro.Workbook\n \n \nType\n.\n\n\nAn excel Workbook, representing a single file. Wrapper around  the Java class \norg.apache.poi.ss.usermodel.Workbook\n. Constructors of this types are used to read existing files, or create new ones.\n\n\n#\n\n\nBase.write\n \n \nFunction\n.\n\n\nwrite(filename::AbstractString, w::Workbook)\n\n\n\n\nWrite a workbook to disk.\n\n\n#\n\n\nTaro.createCellStyle\n \n \nFunction\n.\n\n\ncreate a new cell style from a workbook, prior to setting it on a cell\n\n\n#\n\n\nTaro.createSheet\n \n \nFunction\n.\n\n\ncreateSheet(w::Workbook, s::AbstractString)\n\n\n\n\nCreate a new sheet in the workbook with the specified name.\n\n\n#\n\n\nTaro.extract\n \n \nFunction\n.\n\n\nextract(filename::AbstractString)\n\n\n\n\nExtract raw text from documents, using Apache Tika. Returns a Dict of metadata name value pairs, and a String with the text of the document.\n\n\nfilename: path of file to read. relative to current directory, or absolute\n\n\n\n\n#\n\n\nTaro.fo\n \n \nFunction\n.\n\n\nTaro.fo(inputFoFileName::String, outputPDFFileName::String)\n\n\n\n\nConvert the input \nfo\n file to a PDF.\n\n\n#\n\n\nTaro.fromExcelDate\n \n \nFunction\n.\n\n\nfromExcelDate(date::Number; use1904windowing=false, roundtoSeconds=false)\n\n\n\n\nConvert an Excel style date to a Julia DateTime object.\n\n\nExcel stores dates and times as a floating point number representing the fractional days since 1/1/1900. If \nuse1904windowing\n is true, the epoch is 1/1/1904, which is used in some older Excel for Mac versions. If \nroundtoSeconds\n is true, the millisecond part of the time is discarded.\n\n\n#\n\n\nTaro.getCellFormula\n \n \nFunction\n.\n\n\ngetCellFormula(cell::Cell)\n\n\n\n\n#\n\n\nTaro.getCellType\n \n \nFunction\n.\n\n\ngetCellType(cell::Cell)\n\n\n\n\nReturn the type of a cell: CELL_TYPE_NUMERIC, CELL_TYPE_STRING, CELL_TYPE_FORMULA, CELL_TYPE_BLANK, CELL_TYPE_BOOLEAN, CELL_TYPE_ERROR\n\n\n#\n\n\nTaro.getCellValue\n \n \nFunction\n.\n\n\ngetCellValue(cell::Cell)\n\n\n\n\nReturn the contents of a Excel cell.\n\n\nA string or a float value is returned based on the type of the contents of the cell. If a cell is recognised as a being formatted like a date, a Julia DateTime object is returned. This function therefore is \nnot\n type stable. For formulas, the last evaluated value of the cell is returned.\n\n\nNote that the dates are stored internally within Excel as floats, and the recognition as a date is heuristic.\n\n\nIf a cell contains an error value, or is empty, \nnothing\n is returned.\n\n\n#\n\n\nTaro.getExcelDate\n \n \nFunction\n.\n\n\ngetExcelDate(date::DateTime, use1904windowing::Bool = false)\n\n\n\n\nConvert a Julia DateTime object into an Excel Date. The result will be a floating point number representing days since 1/1/1900. The time from midnight will be the fractional part of the number. If \nuse1904windowing\n is true, the epoch is 1/1/1904, which is used in some older Excel for Mac versions.\n\n\n#\n\n\nTaro.getSheet\n \n \nFunction\n.\n\n\ngetSheet(book::Workbook, sheet)\n\n\n\n\nReturn the specified sheet from the workbook.  sheet can be specified as a name (string) or number (0-indexed)\n\n\n#\n\n\nTaro.isCellDateFormatted\n \n \nFunction\n.\n\n\nisCellDateFormatted(cell::Cell)\n\n\n\n\nReturn true if the format applied to the cell looks like a date.\n\n\nThis is a heuristic, and not guaranteed to be correct.\n\n\n#\n\n\nTaro.readxl\n \n \nFunction\n.\n\n\nRead tabular data out of an excel file into a Julia Dataframe. This is similar to the \nreadtable\n function in the Dataframes package that reads a CSV file into a Dataframe.\n\n\nThe function returns a dataframe from the contents of an MS Excel file. The sheet and region containing the data should be specified. By default, a header row is expected, which must consist only of strings. The \nheader\n keyword argument should be set to \nfalse\n if no header is present in the data.\n\n\nfilename : path of excel file (.xls or .xlsx)\nsheet : sheet name or number (0-based).\n    Can be omitted, in which case the first sheet (index `0`) in the workbook is selected.\nrange : string containing an excel range to read. eg. B4:D45\n\n\n\n\nOptional Arguments : similar to \nDataframes.readtable\n.\n\n\nheader::Bool = true\nnastrings::Vector = ASCIIString[\n, \nNA\n]\ntruestrings::Vector = ASCIIString[\nT\n, \nt\n, \nTRUE\n, \ntrue\n]\nfalsestrings::Vector = ASCIIString[\nF\n, \nf\n, \nFALSE\n, \nfalse\n]\ncolnames::Vector = Symbol[]\ncoltypes::Vector{Any} = Any[]\nskipstart::Int = 0\nskiprows::Vector{Int} = Int[]\nskipblanks::Bool = true\n\n\n\n\n#\n\n\nTaro.setCellFormula\n \n \nFunction\n.\n\n\nsetCellFormula(c::Cell, formula::AbstractString)\n\n\n\n\nSet a formula as a value to an Excel cell.\n\n\nThe formula string should be what you would expect to enter in excel, but without the \n+\n. For example: \"A2+2*B2\" , \"sin(A2)\" , \"some_user_defined_formula(B2)\" Note that the formula will be evaluated only when the file is actually opened in Excel.\n\n\n#\n\n\nTaro.setCellStyle\n \n \nFunction\n.\n\n\nsetCellStyle(cell:Cell, style::CellStyle)\n\n\n\n\nSet a style to a cell. The CellStyle object must be created from the workbook\n\n\n#\n\n\nTaro.setCellValue\n \n \nFunction\n.\n\n\nsetCellValue(c::Cell, x)\n\n\n\n\nSet the value of an excel cell. The value can be a string, a real number, or a Date or DateTime.\n\n\n#\n\n\nTaro.setDataFormat\n \n \nFunction\n.\n\n\nsetDataFormat(w::Workbook, style::CellStyle, format::AbstractString)\n\n\n\n\nSet a dataformat on a CellStyle. Need the workbook to tie everything together", 
            "title": "Reference"
        }
    ]
}