{
    "docs": [
        {
            "location": "/", 
            "text": "Taro \u2013 Work with Excel, Word and PDF files in Julia\n\n\nTaro is a utility belt of functions to work with document files in Julia. It uses \nApache Tika\n, \nApache POI\n and \nApache FOP\n  (via \nJavaCall\n) to work with Word, Excel and PDF files.\n\n\nPackage Features\n\n\n\n\nExtract raw text from Word, Excel, PDF files\n\n\nExtract tabular data from Excel files into a DataFrame (\nreadxl\n, like \nreadtable\n)\n\n\nAPI to read and write Excel files from Julia\n\n\nConvert \nxsl-fo\n files to PDFs for templated document generation\n\n\n\n\nInstallation\n\n\njulia\n Pkg.add(\nTaro\n)\n\n\n\n\nOn installation, the \ntika-app-1.4.jar\n file will be downloaded from \nMaven Central\n and \nfop-2.0\n will be downloaded from an Apache mirror.\n\n\nUsage\n\n\nBefore calling any function within this package, the \ninit()\n method \nmust\n be called. This will set up the correct classpath, and initialise the JVM.\n\n\n using Taro\n Taro.init()", 
            "title": "Home"
        }, 
        {
            "location": "/#taro-work-with-excel-word-and-pdf-files-in-julia", 
            "text": "Taro is a utility belt of functions to work with document files in Julia. It uses  Apache Tika ,  Apache POI  and  Apache FOP   (via  JavaCall ) to work with Word, Excel and PDF files.", 
            "title": "Taro \u2013 Work with Excel, Word and PDF files in Julia"
        }, 
        {
            "location": "/#package-features", 
            "text": "Extract raw text from Word, Excel, PDF files  Extract tabular data from Excel files into a DataFrame ( readxl , like  readtable )  API to read and write Excel files from Julia  Convert  xsl-fo  files to PDFs for templated document generation", 
            "title": "Package Features"
        }, 
        {
            "location": "/#installation", 
            "text": "julia  Pkg.add( Taro )  On installation, the  tika-app-1.4.jar  file will be downloaded from  Maven Central  and  fop-2.0  will be downloaded from an Apache mirror.", 
            "title": "Installation"
        }, 
        {
            "location": "/#usage", 
            "text": "Before calling any function within this package, the  init()  method  must  be called. This will set up the correct classpath, and initialise the JVM.   using Taro\n Taro.init()", 
            "title": "Usage"
        }, 
        {
            "location": "/guide/extract/", 
            "text": "Data Extraction\n\n\nTaro includes a few high level functions that extract data from various document formats.\n\n\nText extraction\n\n\nThe \nTaro.extract\n method retrieves document metadata and the body text of a document, using \nApache Tika\n. Formats \nsupported by Tika\n include MS Office and Open Office documents, as well as PDF files.\n\n\nThe function return a Tuple of a Dict and String. The Dict contains name/value pairs of various metadata from the document, while the string contains the body text of the document.\n\n\n\njulia\n testfile = joinpath(Pkg.dir(),\nTaro\n,\ntest\n,\nWhyJulia.docx\n)\n\n/Users/aviks/.julia/v0.4/Taro/test/WhyJulia.docx\n\n\njulia\n meta, body = Taro.extract(testfile);\n\njulia\n meta[\nLast-Save-Date\n]\n\n2013-12-28T00:17:00Z\n\n\njulia\n typeof(body)\nUTF8String\n\njulia\n body[1:50]\n\nWhy we created Julia\\n\\nIn short, because we are gre\n\n\n\n\n\n\n\nRead Excel files into a DataFrame\n\n\nThe \nTaro.readxl\n method reads a rectangular region from an excel sheet, and returns a \nDataframe\n. This function takes as an input parameter the name and path of the Excel file to be read. A sheet name (or number) can optionally be supplied. If no sheet information is given, the first sheet (index 0) is read. Finally, this function is provided with the rectangular region from which data is extracted. This region is specified as an excel range.\n\n\n\njulia\n testfile = joinpath(Pkg.dir(),\nTaro\n,\ntest\n,\ndf-test.xlsx\n);\n\njulia\n Taro.readxl(testfile, \nSheet1\n, \nB2:F10\n)\n8\u00d75 DataFrames.DataFrame\n\u2502 Row \u2502 H1  \u2502 H2  \u2502 H3  \u2502 H4  \u2502 H5    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 \na\n \u2502 1.0 \u2502 1.0 \u2502 1.0 \u2502 \na a\n \u2502\n\u2502 2   \u2502 \nb\n \u2502 2.0 \u2502 2.0 \u2502 1.0 \u2502 \nb b\n \u2502\n\u2502 3   \u2502 \nc\n \u2502 NA  \u2502 3.0 \u2502 0.0 \u2502 \nc c\n \u2502\n\u2502 4   \u2502 \nd\n \u2502 4.0 \u2502 NA  \u2502 NA  \u2502 \nd d\n \u2502\n\u2502 5   \u2502 \ne\n \u2502 5.0 \u2502 5.0 \u2502 1.0 \u2502 \ne e\n \u2502\n\u2502 6   \u2502 NA  \u2502 6.0 \u2502 6.0 \u2502 1.0 \u2502 \n \n   \u2502\n\u2502 7   \u2502 \ng\n \u2502 7.0 \u2502 7.0 \u2502 1.0 \u2502 \ng g\n \u2502\n\u2502 8   \u2502 \nh\n \u2502 8.0 \u2502 8.0 \u2502 1.0 \u2502 \nh h\n \u2502\n\njulia\n Taro.readxl(testfile, \nSheet1\n, \nB3:F10\n; header=false)\n8\u00d75 DataFrames.DataFrame\n\u2502 Row \u2502 x1  \u2502 x2  \u2502 x3  \u2502 x4  \u2502 x5    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 \na\n \u2502 1.0 \u2502 1.0 \u2502 1.0 \u2502 \na a\n \u2502\n\u2502 2   \u2502 \nb\n \u2502 2.0 \u2502 2.0 \u2502 1.0 \u2502 \nb b\n \u2502\n\u2502 3   \u2502 \nc\n \u2502 NA  \u2502 3.0 \u2502 0.0 \u2502 \nc c\n \u2502\n\u2502 4   \u2502 \nd\n \u2502 4.0 \u2502 NA  \u2502 NA  \u2502 \nd d\n \u2502\n\u2502 5   \u2502 \ne\n \u2502 5.0 \u2502 5.0 \u2502 1.0 \u2502 \ne e\n \u2502\n\u2502 6   \u2502 NA  \u2502 6.0 \u2502 6.0 \u2502 1.0 \u2502 \n \n   \u2502\n\u2502 7   \u2502 \ng\n \u2502 7.0 \u2502 7.0 \u2502 1.0 \u2502 \ng g\n \u2502\n\u2502 8   \u2502 \nh\n \u2502 8.0 \u2502 8.0 \u2502 1.0 \u2502 \nh h\n \u2502\n\njulia\n Taro.readxl(testfile, \nSheet1\n, \nB3:F10\n; header=false, nastrings=[\n \n])\n8\u00d75 DataFrames.DataFrame\n\u2502 Row \u2502 x1  \u2502 x2  \u2502 x3  \u2502 x4  \u2502 x5    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 \na\n \u2502 1.0 \u2502 1.0 \u2502 1.0 \u2502 \na a\n \u2502\n\u2502 2   \u2502 \nb\n \u2502 2.0 \u2502 2.0 \u2502 1.0 \u2502 \nb b\n \u2502\n\u2502 3   \u2502 \nc\n \u2502 NA  \u2502 3.0 \u2502 0.0 \u2502 \nc c\n \u2502\n\u2502 4   \u2502 \nd\n \u2502 4.0 \u2502 NA  \u2502 NA  \u2502 \nd d\n \u2502\n\u2502 5   \u2502 \ne\n \u2502 5.0 \u2502 5.0 \u2502 1.0 \u2502 \ne e\n \u2502\n\u2502 6   \u2502 NA  \u2502 6.0 \u2502 6.0 \u2502 1.0 \u2502 NA    \u2502\n\u2502 7   \u2502 \ng\n \u2502 7.0 \u2502 7.0 \u2502 1.0 \u2502 \ng g\n \u2502\n\u2502 8   \u2502 \nh\n \u2502 8.0 \u2502 8.0 \u2502 1.0 \u2502 \nh h\n \u2502", 
            "title": "Extraction"
        }, 
        {
            "location": "/guide/extract/#data-extraction", 
            "text": "Taro includes a few high level functions that extract data from various document formats.", 
            "title": "Data Extraction"
        }, 
        {
            "location": "/guide/extract/#text-extraction", 
            "text": "The  Taro.extract  method retrieves document metadata and the body text of a document, using  Apache Tika . Formats  supported by Tika  include MS Office and Open Office documents, as well as PDF files.  The function return a Tuple of a Dict and String. The Dict contains name/value pairs of various metadata from the document, while the string contains the body text of the document.  \njulia  testfile = joinpath(Pkg.dir(), Taro , test , WhyJulia.docx ) /Users/aviks/.julia/v0.4/Taro/test/WhyJulia.docx \n\njulia  meta, body = Taro.extract(testfile);\n\njulia  meta[ Last-Save-Date ] 2013-12-28T00:17:00Z \n\njulia  typeof(body)\nUTF8String\n\njulia  body[1:50] Why we created Julia\\n\\nIn short, because we are gre", 
            "title": "Text extraction"
        }, 
        {
            "location": "/guide/extract/#read-excel-files-into-a-dataframe", 
            "text": "The  Taro.readxl  method reads a rectangular region from an excel sheet, and returns a  Dataframe . This function takes as an input parameter the name and path of the Excel file to be read. A sheet name (or number) can optionally be supplied. If no sheet information is given, the first sheet (index 0) is read. Finally, this function is provided with the rectangular region from which data is extracted. This region is specified as an excel range.  \njulia  testfile = joinpath(Pkg.dir(), Taro , test , df-test.xlsx );\n\njulia  Taro.readxl(testfile,  Sheet1 ,  B2:F10 )\n8\u00d75 DataFrames.DataFrame\n\u2502 Row \u2502 H1  \u2502 H2  \u2502 H3  \u2502 H4  \u2502 H5    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502  a  \u2502 1.0 \u2502 1.0 \u2502 1.0 \u2502  a a  \u2502\n\u2502 2   \u2502  b  \u2502 2.0 \u2502 2.0 \u2502 1.0 \u2502  b b  \u2502\n\u2502 3   \u2502  c  \u2502 NA  \u2502 3.0 \u2502 0.0 \u2502  c c  \u2502\n\u2502 4   \u2502  d  \u2502 4.0 \u2502 NA  \u2502 NA  \u2502  d d  \u2502\n\u2502 5   \u2502  e  \u2502 5.0 \u2502 5.0 \u2502 1.0 \u2502  e e  \u2502\n\u2502 6   \u2502 NA  \u2502 6.0 \u2502 6.0 \u2502 1.0 \u2502       \u2502\n\u2502 7   \u2502  g  \u2502 7.0 \u2502 7.0 \u2502 1.0 \u2502  g g  \u2502\n\u2502 8   \u2502  h  \u2502 8.0 \u2502 8.0 \u2502 1.0 \u2502  h h  \u2502\n\njulia  Taro.readxl(testfile,  Sheet1 ,  B3:F10 ; header=false)\n8\u00d75 DataFrames.DataFrame\n\u2502 Row \u2502 x1  \u2502 x2  \u2502 x3  \u2502 x4  \u2502 x5    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502  a  \u2502 1.0 \u2502 1.0 \u2502 1.0 \u2502  a a  \u2502\n\u2502 2   \u2502  b  \u2502 2.0 \u2502 2.0 \u2502 1.0 \u2502  b b  \u2502\n\u2502 3   \u2502  c  \u2502 NA  \u2502 3.0 \u2502 0.0 \u2502  c c  \u2502\n\u2502 4   \u2502  d  \u2502 4.0 \u2502 NA  \u2502 NA  \u2502  d d  \u2502\n\u2502 5   \u2502  e  \u2502 5.0 \u2502 5.0 \u2502 1.0 \u2502  e e  \u2502\n\u2502 6   \u2502 NA  \u2502 6.0 \u2502 6.0 \u2502 1.0 \u2502       \u2502\n\u2502 7   \u2502  g  \u2502 7.0 \u2502 7.0 \u2502 1.0 \u2502  g g  \u2502\n\u2502 8   \u2502  h  \u2502 8.0 \u2502 8.0 \u2502 1.0 \u2502  h h  \u2502\n\njulia  Taro.readxl(testfile,  Sheet1 ,  B3:F10 ; header=false, nastrings=[   ])\n8\u00d75 DataFrames.DataFrame\n\u2502 Row \u2502 x1  \u2502 x2  \u2502 x3  \u2502 x4  \u2502 x5    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502  a  \u2502 1.0 \u2502 1.0 \u2502 1.0 \u2502  a a  \u2502\n\u2502 2   \u2502  b  \u2502 2.0 \u2502 2.0 \u2502 1.0 \u2502  b b  \u2502\n\u2502 3   \u2502  c  \u2502 NA  \u2502 3.0 \u2502 0.0 \u2502  c c  \u2502\n\u2502 4   \u2502  d  \u2502 4.0 \u2502 NA  \u2502 NA  \u2502  d d  \u2502\n\u2502 5   \u2502  e  \u2502 5.0 \u2502 5.0 \u2502 1.0 \u2502  e e  \u2502\n\u2502 6   \u2502 NA  \u2502 6.0 \u2502 6.0 \u2502 1.0 \u2502 NA    \u2502\n\u2502 7   \u2502  g  \u2502 7.0 \u2502 7.0 \u2502 1.0 \u2502  g g  \u2502\n\u2502 8   \u2502  h  \u2502 8.0 \u2502 8.0 \u2502 1.0 \u2502  h h  \u2502", 
            "title": "Read Excel files into a DataFrame"
        }, 
        {
            "location": "/guide/hssf/", 
            "text": "Read and Write Excel Files\n\n\nThe \nTaro.readxl\n function above is a simple, high level method to read tabular data from Excel files into a Julia DataFrames. For more control over reading files cell by cell, and for creating or modifyting  excel files,  this package exposes functions to read, create and write workbooks, sheets, rows and cells. The functions are modelled on the underlying POI API (converted to functional form), which in turn is based on the structure of an Excel file.\n\n\nt=now()\nw=Workbook()\ns=createSheet(w, \nruntests\n)\nr=createRow(s, 1)\nc=createCell(r, 1); setCellValue(c, \nA String\n)\nc=createCell(r, 2); setCellValue(c, 25)\nc=createCell(r, 3); setCellValue(c, 2.5)\nc=createCell(r, 4); setCellValue(c, t)\nc=createCell(r, 5); setCellFormula(c, \nC2+D2\n)\nwrite(Pkg.dir(\nTaro\n, \ntest\n, \nwrite-tests.xlsx\n), w)\n\n\n\n\nWe can now read the file we just wrote, and verify the values we inserted.\n\n\n\njulia\n w2=Workbook(Pkg.dir(\nTaro\n, \ntest\n, \nwrite-tests.xlsx\n))\nJavaCall.JavaObject{symbol(\norg.apache.poi.ss.usermodel.Workbook\n)}(Ptr{Void} @0x00007f9329fbea60)\n\njulia\n s2 = getSheet(w2, \nruntests\n)\nJavaCall.JavaObject{symbol(\norg.apache.poi.ss.usermodel.Sheet\n)}(Ptr{Void} @0x00007f9329fbea50)\n\njulia\n r2 = getRow(s2, 1)\nJavaCall.JavaObject{symbol(\norg.apache.poi.ss.usermodel.Row\n)}(Ptr{Void} @0x00007f9329fbea48)\n\njulia\n c2 = getCell(r2, 1); getCellValue(c2)\n\nA String\n\n\njulia\n c2 = getCell(r2, 2); getCellValue(c2)\n25.0\n\njulia\n c2 = getCell(r2, 3); getCellValue(c2)\n2.5\n\njulia\n c2 = getCell(r2, 4); fromExcelDate(getCellValue(c2))\n2016-06-14T15:25:51\n\njulia\n c2 = getCell(r2, 5); getCellFormula(c2)\n\nC2+D2", 
            "title": "Excel"
        }, 
        {
            "location": "/guide/hssf/#read-and-write-excel-files", 
            "text": "The  Taro.readxl  function above is a simple, high level method to read tabular data from Excel files into a Julia DataFrames. For more control over reading files cell by cell, and for creating or modifyting  excel files,  this package exposes functions to read, create and write workbooks, sheets, rows and cells. The functions are modelled on the underlying POI API (converted to functional form), which in turn is based on the structure of an Excel file.  t=now()\nw=Workbook()\ns=createSheet(w,  runtests )\nr=createRow(s, 1)\nc=createCell(r, 1); setCellValue(c,  A String )\nc=createCell(r, 2); setCellValue(c, 25)\nc=createCell(r, 3); setCellValue(c, 2.5)\nc=createCell(r, 4); setCellValue(c, t)\nc=createCell(r, 5); setCellFormula(c,  C2+D2 )\nwrite(Pkg.dir( Taro ,  test ,  write-tests.xlsx ), w)  We can now read the file we just wrote, and verify the values we inserted.  \njulia  w2=Workbook(Pkg.dir( Taro ,  test ,  write-tests.xlsx ))\nJavaCall.JavaObject{symbol( org.apache.poi.ss.usermodel.Workbook )}(Ptr{Void} @0x00007f9329fbea60)\n\njulia  s2 = getSheet(w2,  runtests )\nJavaCall.JavaObject{symbol( org.apache.poi.ss.usermodel.Sheet )}(Ptr{Void} @0x00007f9329fbea50)\n\njulia  r2 = getRow(s2, 1)\nJavaCall.JavaObject{symbol( org.apache.poi.ss.usermodel.Row )}(Ptr{Void} @0x00007f9329fbea48)\n\njulia  c2 = getCell(r2, 1); getCellValue(c2) A String \n\njulia  c2 = getCell(r2, 2); getCellValue(c2)\n25.0\n\njulia  c2 = getCell(r2, 3); getCellValue(c2)\n2.5\n\njulia  c2 = getCell(r2, 4); fromExcelDate(getCellValue(c2))\n2016-06-14T15:25:51\n\njulia  c2 = getCell(r2, 5); getCellFormula(c2) C2+D2", 
            "title": "Read and Write Excel Files"
        }, 
        {
            "location": "/guide/fo/", 
            "text": "", 
            "title": "XSL-FO"
        }, 
        {
            "location": "/api/", 
            "text": "Types and Function Reference\n\n\n\n\nTaro.extract\n\n\nTaro.fromExcelDate\n\n\nTaro.getExcelDate\n\n\nTaro.readxl\n\n\n\n\n#\n\n\nTaro.extract\n \n \nFunction\n.\n\n\nextract(filename::AbstractString)\n\n\n\n\nExtract raw text from documents, using Apache Tika. Returns a Dict of metadata name value pairs, and a String with the text of the document.\n\n\nfilename: path of file to read. relative to current directory, or absolute\n\n\n\n\n#\n\n\nTaro.fromExcelDate\n \n \nFunction\n.\n\n\nfromExcelDate(date::Number; use1904windowing=false, roundtoSeconds=false)\n\n\n\n\nConvert an Excel style date to a Julia DateTime object.    Excel stores dates and times as a floating point number    representing the fractional days since 1/1/1900. If \nuse1904windowing\n is true, the epoch is 1/1/1904,    which is used in some older Excel for Mac versions. If \nroundtoSeconds\n is true, the millisecond    part of the time is discarded.\n\n\n#\n\n\nTaro.getExcelDate\n \n \nFunction\n.\n\n\ngetExcelDate(date::DateTime, use1904windowing::Bool = false)\n\n\n\n\nConvert a Julia DateTime object into an Excel Date. The result will be a floating point number representing days since 1/1/1900. The time from midnight will be the fractional part of the number. If \nuse1904windowing\n is true, the epoch is 1/1/1904, which is used in some older Excel for Mac versions.\n\n\n#\n\n\nTaro.readxl\n \n \nFunction\n.\n\n\nRead tabular data out of an excel file into a Julia Dataframe. This is similar to the \nreadtable\n function in the Dataframes package that reads a CSV file into a Dataframe.\n\n\nThe function returns a dataframe from the contents of an MS Excel file. The sheet and region containing the data should be specified. By default, a header row is expected, which must consist only of strings. The \nheader\n keyword argument should be set to \nfalse\n if no header is present in the data.\n\n\nfilename : path of excel file (.xls or .xlsx)\nsheet : sheet name or number (0-based).\n    Can be omitted, in which case the first sheet (index `0`) in the workbook is selected.\nrange : string containing an excel range to read. eg. B4:D45\n\n\n\n\nOptional Arguments : similar to \nDataframes.readtable\n.\n\n\nheader::Bool = true\nnastrings::Vector = ASCIIString[\n, \nNA\n]\ntruestrings::Vector = ASCIIString[\nT\n, \nt\n, \nTRUE\n, \ntrue\n]\nfalsestrings::Vector = ASCIIString[\nF\n, \nf\n, \nFALSE\n, \nfalse\n]\ncolnames::Vector = Symbol[]\ncoltypes::Vector{Any} = Any[]\nskipstart::Int = 0\nskiprows::Vector{Int} = Int[]\nskipblanks::Bool = true", 
            "title": "Reference"
        }, 
        {
            "location": "/api/#types-and-function-reference", 
            "text": "Taro.extract  Taro.fromExcelDate  Taro.getExcelDate  Taro.readxl   #  Taro.extract     Function .  extract(filename::AbstractString)  Extract raw text from documents, using Apache Tika. Returns a Dict of metadata name value pairs, and a String with the text of the document.  filename: path of file to read. relative to current directory, or absolute  #  Taro.fromExcelDate     Function .  fromExcelDate(date::Number; use1904windowing=false, roundtoSeconds=false)  Convert an Excel style date to a Julia DateTime object.    Excel stores dates and times as a floating point number    representing the fractional days since 1/1/1900. If  use1904windowing  is true, the epoch is 1/1/1904,    which is used in some older Excel for Mac versions. If  roundtoSeconds  is true, the millisecond    part of the time is discarded.  #  Taro.getExcelDate     Function .  getExcelDate(date::DateTime, use1904windowing::Bool = false)  Convert a Julia DateTime object into an Excel Date. The result will be a floating point number representing days since 1/1/1900. The time from midnight will be the fractional part of the number. If  use1904windowing  is true, the epoch is 1/1/1904, which is used in some older Excel for Mac versions.  #  Taro.readxl     Function .  Read tabular data out of an excel file into a Julia Dataframe. This is similar to the  readtable  function in the Dataframes package that reads a CSV file into a Dataframe.  The function returns a dataframe from the contents of an MS Excel file. The sheet and region containing the data should be specified. By default, a header row is expected, which must consist only of strings. The  header  keyword argument should be set to  false  if no header is present in the data.  filename : path of excel file (.xls or .xlsx)\nsheet : sheet name or number (0-based).\n    Can be omitted, in which case the first sheet (index `0`) in the workbook is selected.\nrange : string containing an excel range to read. eg. B4:D45  Optional Arguments : similar to  Dataframes.readtable .  header::Bool = true\nnastrings::Vector = ASCIIString[ ,  NA ]\ntruestrings::Vector = ASCIIString[ T ,  t ,  TRUE ,  true ]\nfalsestrings::Vector = ASCIIString[ F ,  f ,  FALSE ,  false ]\ncolnames::Vector = Symbol[]\ncoltypes::Vector{Any} = Any[]\nskipstart::Int = 0\nskiprows::Vector{Int} = Int[]\nskipblanks::Bool = true", 
            "title": "Types and Function Reference"
        }
    ]
}